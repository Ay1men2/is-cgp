
````markdown
# RLM 工程范围定义（RLM Scope）

> **文档目的**
>
> 本文档用于明确 RLM（Retrieval / Logic / Memory）在 **IS-CGP**
> 中的**工程语义、职责边界与可验证标准**。
>
> 本文档不是论文方法描述，而是一个
> **工程约束与实现契约（Engineering Contract）**，
> 用于指导后续代码实现、评审与系统演进。

---

## 0. 工程化 RLM 的定位声明（重要）

> **说明**
>
> 本文所述 RLM 为 IS-CGP 场景下的**工程化 RLM**，
> 并非对学术论文中 *Recursive Language Model* 推理范式的完整复现。
>
> 其目标不是最大化模型推理能力，
> 而是在**高合规、可审计、可回放的内网系统中**
> 提供一个**受控的上下文治理执行单元**。
>
> 因此：
>
> - 工程 RLM 是**被主动约束与裁剪的**
> - 确定性、可解释性优先于智能性
> - 可治理性优先于效果最优

---

## 1. RLM 在 IS-CGP 中的工程定义

### 1.1 核心定义

在 IS-CGP 中，**RLM 不被视为一种模型能力或算法框架**。

在工程层面，其定义为：

> **RLM = 上下文治理流水线（Context Governance Pipeline）**
>
> 一个在模型推理之前执行的、
> **确定性的、可记录的决策过程**，
> 用于回答一个问题：
>
> **「哪些信息可以进入模型上下文？为什么？」**

RLM 与具体推理引擎实现
（如 llama.cpp、vLLM、OpenAI API 等）
**完全解耦**。

---

### 1.2 工程目标（非算法目标）

RLM 的工程目标 **不是提升模型回答效果**，
而是保证：

1. 上下文选择过程 **受治理规则约束**
2. 决策逻辑 **显式、可解释**
3. 每一次决策 **可审计、可重放**
4. 治理逻辑 **不依赖推理引擎内部实现**

---

## 2. 职责范围与边界

### 2.1 RLM 负责的内容（In Scope）

RLM 在 IS-CGP 中承担以下工程职责：

---

#### 1️⃣ 检索（Retrieval，受治理）

- 从受控数据源中选取候选上下文单元（artifacts）
- 数据源可以包括但不限于：
  - 文档
  - 代码片段
  - 缓存内容
  - 历史会话状态
- 检索过程必须受以下约束：
  - 项目 / 会话边界
  - 治理策略规则
  - 元数据或安全标签

> 是否使用向量检索、关键词检索或其他方式，
> 属于实现选择，而非 RLM 定义前提。

---

#### 2️⃣ 治理逻辑（Logic / Reasoning）

- 对候选上下文执行：
  - 过滤（filter）
  - 排序（rank）
  - 截断（truncate）
- 决策逻辑可以基于：
  - 显式规则
  - 确定性评分或启发式策略
  - 会话 / 项目状态判断

**强约束：**

> RLM 中的治理逻辑必须为：
>
> - 非生成式
> - 非语言模型依赖
> - 行为确定、可解释
>
> 不得依赖 LLM 的自由文本生成结果
> 作为上下文治理决策依据。

---

#### 3️⃣ 记忆与状态（Memory）

- 管理以下状态信息：
  - 会话级状态
  - 项目级状态
- 支持跨请求的一致性治理行为
- 用于长上下文与多轮交互场景下的稳定决策
- 不承担知识学习或语义记忆功能

---

#### 4️⃣ 决策记录（Trace Recording）

- 对每次 RLM 执行进行结构化记录，包括：
  - 候选上下文单元列表
  - 被选中单元
  - 被排除单元
  - 触发的规则、策略或状态条件
- 决策记录必须：
  - 结构化
  - 可持久化
  - 可用于审计、回放与调试

---

### 2.2 RLM 明确不负责的内容（Out of Scope）

RLM **不承担** 以下职责：

- 模型推理或模型调用
- 模型训练、微调或参数优化
- Prompt 文案或生成效果优化
- Agent / Planner / 多步执行系统
- 自动规划或自治决策
- 学习型或自适应策略优化

> RLM 不等价于 Agent，也不演进为 Agent。

---

## 3. 最小输入 / 输出契约

### 3.1 最小输入

```text
session_id
query
````

前提假设：

* `session_id` 已通过上游系统的认证与隔离
* `query` 为用户原始输入，RLM 不修改其语义

> 注：后续版本可能扩展输入字段，
> 如 `project_id`、`policy_context`、`request_metadata`，
> 但不影响 v0 的工程语义。

---

### 3.2 最小输出

RLM 的输出必须包含以下两部分：

---

#### 1️⃣ 上下文拼装结果（Assembled Context）

* 可直接用于下游推理的上下文结构
* 形式可以是：

  * 拼装后的 prompt
  * 或结构化上下文对象

---

#### 2️⃣ 决策轨迹（Decision Trace）

* 用于审计与调试的结构化记录
* 至少包含：

  * 候选上下文列表
  * 选中项
  * 排除项
  * 决策依据（规则 / 策略 / 状态）

---

## 4. 一次 RLM 执行的生命周期

```text
输入（session_id, query）
        ↓
候选上下文检索
        ↓
治理逻辑（过滤 / 排序 / 截断）
        ↓
上下文拼装
        ↓
决策轨迹记录
        ↓
输出
```

**关键约束：**

> 在相同输入与相同状态快照下，
> RLM 的执行结果必须是
> **确定的、可重放的**。
> RLM 必须完整记录一次执行过程中
> 所发生的上下文选择与决策行为，
> 以支持事后回放与行为解释。

---

## 5. 工程验收标准（Acceptance Criteria）

一个 RLM 实现被认为是工程可接受的，必须满足：

1. **可解释性**

   * 任一上下文单元的纳入或排除均有明确原因
2. **可重放性**

   * 在相同输入与状态下结果完全一致
   * 支持对单次执行过程的完整回放
   * 包括输入、上下文选择与决策依据
3. **可审计性**

   * 决策过程以结构化形式持久化
4. **与推理引擎解耦**

   * 治理逻辑不依赖模型内部实现

---

## 6. 与 IS-CGP 其他模块的关系

* RLM 是 IS-CGP 内部的治理执行单元
* 不直接作为用户可见功能暴露
* 是以下能力的基础支撑：

  * 上下文治理
  * 长上下文控制
  * 缓存治理
  * 证据链生成

---

## 7. 非目标声明（Non-Goals）

当前阶段，RLM 不追求：

* 自动规划或自治行为
* 多 Agent 协同
* 自学习策略演化
* 回答质量或效果评测

---

## 8. 版本与演进说明

* 本文档定义 **RLM v0 的工程语义**
* 后续版本可扩展：

  * 决策维度
  * 轨迹粒度
  * 状态管理方式
* **核心治理原则保持稳定**

```

